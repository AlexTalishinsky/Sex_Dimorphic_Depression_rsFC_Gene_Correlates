function [gene_loading_weights, gene_LW_ranklist, model_corr, p_rand, p_spin] = run_PLS(rsFC_vector, sphereHCP, ROI_expression_mat, perm_mat_spin)
%run_PLS: This function performs partial least squares regression between a
%neuroimaging vector 'Y' and a regional gene expression matrix 'X'

%Inputs:
%    - rsFC_vector: 360-element column vector representing a neuorimaging-
%      derived statistic over 180 L hemisphere Glasser ROIs followed by 180 R
%      hemisphere Glasser ROIs
%    - sphereHCP: MNI coordinates for the spherical projection of 360
%      Glasser ROIs (L hemisphere then R). This file is included in the
%      folder containing this function.
%    - ROI_expression_mat (optional): 360-row matrix representing brain gene 
%      expression values at 180 L hemisphere Glasser ROIs followed by 180 R
%      hemisphere ROIs. This matrix may be generated by the accompanying 
%      function, 'map_gene2GlasserROIs.m'. If not provided, this input will
%      be generated by default from six downloaded AHBA subject data folders
%      if they have been added to the Matlab search path. 
%    - perm_mat_spin (optional): A 360 x 10000 permutation matrix generated
%      by the 'rotate_parcellation' function from the 'rotate-parcellation' 
%      package downloaded from Github. If none provided, this will be
%      generated by default from the 'sphereHCP' file if the
%      'rotate-parcellation' package has been added to the Matlab search
%      path. 


%To run this function, the following dependencies must be added to the
%Matlab search path:
%    - 'spls' package by Joao M. Monteiro; available for download at: 
%      <https://github.com/jmmonteiro/spls>
%    - 'rotate-parcellation' package by Frantisek Vasa; available
%      for download at:
%      <https://github.com/frantisekvasa/rotate_parcellation>
%    - If 'ROI_expression_mat' variable not included, any dependencies for
%      accompanying function 'map_gene2GlasserROIs' must also be added 
%      to the Matlab search path. 


%Outputs: 
%    - gene_loading_weights: PLS loading weights for genes (columns) in
%      ROI_expression_mat
%    - gene_LW_ranklist: genes ranked by the ratio of their loading weight
%      to the standard deviation of 10,000 LWs from a bootstrap-resampled 
%      null model
%    - model_corr: correlation between gene PLS loading scores and rsFC
%      vector
%    - p_rand: percentile of empirical model_corr in null distribution of
%      correlations resulting from random permutation of Y-vector rows
%    - p_spin: percentile of empirical model_corr in null distribution of
%      correlations resulting from random rotation of spherical projection 
%      of Y-vector rows



%% generate gene expression mat if none provided:

%check if ROI_expression_mat provided
if ~exist('ROI_expression_mat', 'var')
    warning('Regional gene expression matrix not provided. Trying to generate default from AHBA data.')

    %run map_gene2GlasserROIs on each AHBA subject to convert downloaded
    %AHBA data to a region-by-gene expression matrix
    [subj9861] = map_gene2GlasserROIs('normalized_microarray_donor9861/MicroarrayExpression.csv','normalized_microarray_donor9861/SampleAnnot.csv','normalized_microarray_donor9861/Ontology.csv','normalized_microarray_donor9861/Probes.csv');
    [subj10021] = map_gene2GlasserROIs('normalized_microarray_donor10021/MicroarrayExpression.csv','normalized_microarray_donor10021/SampleAnnot.csv','normalized_microarray_donor10021/Ontology.csv','normalized_microarray_donor10021/Probes.csv');
    [subj12876] = map_gene2GlasserROIs('normalized_microarray_donor12876/MicroarrayExpression.csv','normalized_microarray_donor12876/SampleAnnot.csv','normalized_microarray_donor12876/Ontology.csv','normalized_microarray_donor12876/Probes.csv');
    [subj14380] = map_gene2GlasserROIs('normalized_microarray_donor14380/MicroarrayExpression.csv','normalized_microarray_donor14380/SampleAnnot.csv','normalized_microarray_donor14380/Ontology.csv','normalized_microarray_donor14380/Probes.csv');
    [subj15496] = map_gene2GlasserROIs('normalized_microarray_donor15496/MicroarrayExpression.csv','normalized_microarray_donor15496/SampleAnnot.csv','normalized_microarray_donor15496/Ontology.csv','normalized_microarray_donor15496/Probes.csv');
    [subj15697] = map_gene2GlasserROIs('normalized_microarray_donor15697/MicroarrayExpression.csv','normalized_microarray_donor15697/SampleAnnot.csv','normalized_microarray_donor15697/Ontology.csv','normalized_microarray_donor15697/Probes.csv');
    %demean and normalize each subject
    subj9861(2:end,:) = (subj9861(2:end,:) - nanmean(subj9861(2:end,:))) ./ nanstd(subj9861(2:end,:));
    subj10021(2:end,:) = (subj10021(2:end,:) - nanmean(subj10021(2:end,:))) ./ nanstd(subj10021(2:end,:));
    subj12876(2:end,:) = (subj12876(2:end,:) - nanmean(subj12876(2:end,:))) ./ nanstd(subj12876(2:end,:));
    subj14380(2:end,:) = (subj14380(2:end,:) - nanmean(subj14380(2:end,:))) ./ nanstd(subj14380(2:end,:));
    subj15496(2:end,:) = (subj15496(2:end,:) - nanmean(subj15496(2:end,:))) ./ nanstd(subj15496(2:end,:));
    subj15697(2:end,:) = (subj15697(2:end,:) - nanmean(subj15697(2:end,:))) ./ nanstd(subj15697(2:end,:));
    %mean over all subjects
    ROI_expression_mat = nanmean(cat(3,subj9861, subj10021, subj12876, subj14380, subj15496, subj15697),3);
    clear subj9861 subj10021 subj12876 subj14380 subj15496 subj15697
    
end
    
%% Prepare gene and rsFC matrices for PLS

%mirror 

%Remove ROIs with no AHBA gene expression coverage
Gene_ROI_NaN_index = find(isnan(ROI_expression_mat(2:end,1)));
ROI_expression_mat = ROI_expression_mat(~ismember(1:size(ROI_expression_mat,1),1+Gene_ROI_NaN_index),:);
rsFC_vector = rsFC_vector(~ismember(1:size(rsFC_vector,1),Gene_ROI_NaN_index),:);

%demean and normalize X and Y matrices  
ROI_expression_mat(2:end,:) = (ROI_expression_mat(2:end,:) - mean(ROI_expression_mat(2:end,:))) ./ std(ROI_expression_mat(2:end,:));
rsFC_vector = (rsFC_vector - mean(rsFC_vector)) ./ std(rsFC_vector);


%% Generate random permutation matrix

%set bootstrap count
bootstrap_count = 10000;

%set random seed
rng(1)
%generate random permutation matrix using 'randperm'
temp_range = size(ROI_expression_mat(2:end,:),1);
for i = 1:bootstrap_count
    perm_mat_rand(:,i) = randperm(temp_range);
end
    
%% Generate random spherical rotation matrix

if ~exist('perm_mat_spin', 'var')
    warning('Spherical rotation matrix not provided. Trying to generate default from sphere_HCP')
    
    sphereHCP_L = sphereHCP(1:180,:);
    sphereHCP_R = sphereHCP(181:360,:);
    rng(1)
    perm_mat_spin = rotate_parcellation(table2array(sphereHCP_L(~ismember(1:180,Gene_ROI_NaN_index(1:max(find(Gene_ROI_NaN_index < 180)))),:)), table2array(sphereHCP_R(~ismember(181:360,Gene_ROI_NaN_index((max(find(Gene_ROI_NaN_index < 180))+1):end)),:)), bootstrap_count);

end

%% Run PLS to determine model loading score correlation and p-values

warning off %suppress non-sparsity warning in 'spls' function

%null model using random permutation of Y-vector rows
for i = 1:bootstrap_count
    [gene_loading_weights,temp_v] = spls(ROI_expression_mat(2:end,:), rsFC_vector(perm_mat_rand(:,i)), 1000,1);
    null_corr_rand(i) = corr(ROI_expression_mat(2:end,:) * gene_loading_weights, rsFC_vector(perm_mat_rand(:,i)) * temp_v);
end

%null model using random rotation of spherical projection of Y-vector rows
for i = 1:bootstrap_count
    [gene_loading_weights,temp_v] = spls(ROI_expression_mat(2:end,:), rsFC_vector(perm_mat_spin(:,i)), 1000,1);
    null_corr_spin(i) = corr(ROI_expression_mat(2:end,:) * gene_loading_weights, rsFC_vector(perm_mat_spin(:,i)) * temp_v);
end

%compare empirical correlation to null distribution
[gene_loading_weights,~] = spls(ROI_expression_mat(2:end,:),rsFC_vector,1000,1);
model_corr = corr(ROI_expression_mat(2:end,:) * gene_loading_weights,rsFC_vector);
p_rand = sum(null_corr_rand(1:bootstrap_count) > model_corr)/bootstrap_count;
p_spin = sum(null_corr_spin(1:bootstrap_count) > model_corr)/bootstrap_count;


%% rank genes by PLS loading weight

%set random seed
rng(1)

%generate null distribution of gene loading weights using
%bootstrap-resampling procedure
null_temp_u = zeros(bootstrap_count,size(ROI_expression_mat,2));
for i = 1:bootstrap_count
    [null_ROI_expression_mat,null_idx] = datasample(ROI_expression_mat(2:end,:),size(ROI_expression_mat(2:end,:),1));
    resampled_rsFC_vector = rsFC_vector(null_idx);
    [null_temp_u(i,:),~] = spls(null_ROI_expression_mat,resampled_rsFC_vector,1000,1);
end

%correct gene_loading_weights according to stability
gene_loading_weights = gene_loading_weights ./ std(null_temp_u,0,1)';
 
%generate gene ranklist 
[~,temp_gene_ranks] = sort(gene_loading_weights,'descend');
gene_LW_ranklist = ROI_expression_mat(1,temp_gene_ranks)';
gene_LW_ranklist(:,2) = gene_loading_weights(temp_gene_ranks);

end



    